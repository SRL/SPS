{$loadlib sps}

{$include_once srl-6/lib/interfaces/minimap.simba}
{$include_once srl-6/lib/core/debug.simba}
{$include_once srl-6/lib/core/players.simba}
{$include_once srl-6/lib/utilities/drawing.simba}

type
  TSPSArea = record
    __mapPath: string;
    __areaMap: T3DIntegerArray;
    _accuracy: integer;
    _tolerance, _minMatchPercent: extended;
    isSetup: boolean;
  end;

const
  SPS_IMG_PATH = IncludePath + 'SPS\img\';
  SPS_IMG_FMT  = '.png';

const
  RUNESCAPE_SURFACE = 'runescape_surface\';
  RUNESCAPE_OTHER = 'runescape_other\';

const
  __DEFAULT_ACCURACY: integer = 4;
  __DEFAULT_TOLERANCE: extended = 600.0;
  __DEFAULT_MIN_MATCH_PERCENT: extended = 0.40;

var
  spsAnyAngle: boolean = false;
  spsMultiMouse: boolean = true;

var
  sps: TSPSArea;

(*
  Returns the name of the TSPSArea variable.

  Example:
    writeln(sps.getName());
*)
function TSPSArea.getName(): string;
begin
  result := between('"', '"', toStr(@self));
end;

(*
  Loads and setups the TSPSArea.

  Example:
    sps.setup('my_map_name', RUNESCAPE_SURFACE, 4, 600.0, 0.40);
*)
procedure TSPSArea.setup(imgName, imgFolder: string; accuracy: integer; tolerance, minMatchPercent: extended);
var
  bmp: TMufasaBitmap;
  t: integer;
  m: extended;
begin
  print(self.getName()+'.init()', TDebug.HEADER);

  t := getSystemTime();

  if (fileExists(SPS_IMG_PATH + imgFolder + imgName + SPS_IMG_FMT)) then
  begin
    print('Path exists ('+SPS_IMG_PATH + imgFolder + imgName + SPS_IMG_FMT+')');

    self._accuracy := accuracy;
    self._tolerance := tolerance;
    self._minMatchPercent := minMatchPercent;
    self.__mapPath := SPS_IMG_PATH + imgFolder + imgName + SPS_IMG_FMT;

    if (spsAnyAngle) then
      self._minMatchPercent := 0.10;

    try
      bmp.init(client.getMBitmaps());
      bmp.loadFromFile(self.__mapPath);

      SPS_BitmapToMap(bmp, self._accuracy, self.__areaMap);
    except
      print(self.getName()+'.setup(): Unable to load map or bitmap to map failed', TDebug.FATAL);
    finally
      bmp.free();
    end;

    self.isSetup := true;
  end else
    print(self.getName()+'.setup(): Unable to find map, searched path '+ SPS_IMG_PATH + imgFolder + imgName + SPS_IMG_FMT, TDebug.FATAL);

  print('Setup area "' + imgName + '" in ' + intToStr(getSystemTime() - t) + 'ms');
  print(self.getName()+'.init()', TDebug.FOOTER);
end;

(*
  Overloaded: Loads and setups the TSPSArea without the need for accuracy, tolerance, and min match percent variables.

  Example:
    sps.setup('my_map_name', RUNESCAPE_SURFACE);
*)
procedure TSPSArea.setup(imgName, imgFolder: string); overload;
begin
  self.setup(imgName, imgFolder, __DEFAULT_ACCURACY, __DEFAULT_TOLERANCE,
             __DEFAULT_MIN_MATCH_PERCENT);
end;

function SPS_GatherMinimap: TMufasaBitmap;
begin
  result.init();
  result.setSize(140, 140);

  try
    result.copyClientToBitmap(client.getIOManager(), false, minimap.cx - 70,
                              minimap.cy - 70, minimap.cx + 70, minimap.cy + 70);
  except
    print('Failed to gather the minimap', TDebug.ERROR);
  end;
end;

function SPS_GatherRotatedMinimap(): TMufasaBitmap;
var
  bmp: TMufasaBitmap;
  a: extended;
begin
  a := minimap.getAngleRadians();

  if (not inRange(degrees(a), 8, 352)) then
  begin
    result := SPS_GatherMinimap();
    exit();
  end;

  bmp.init();
  bmp.setSize(140, 140);

  result.init();

  try
    bmp.copyClientToBitmap(client.getIOManager(), false, minimap.cx - 70,
                           minimap.cy -70, minimap.cx + 70, minimap.cy + 70);

    bmp.rotateBitmap(a, result);
  except
    print('Failed to gather the minimap', TDebug.ERROR);
  finally
    bmp.free();
  end;
end;

procedure TSPSArea.debugPlayerPos();
var
  b: TBox;
  bmp, w, h, t: integer;
  mid, pos: TPoint;
begin
  t := getSystemTime();
  pos := self.getPlayerPos();
  t := (getSystemTime() - t);

  if (pos.x = -1) then
    exit;

  bmp := loadBitmap(self.__mapPath);

  getBitmapSize(bmp, w, h);
  dec(w); dec(h);

  // draw our postion, and a 120 radius area around our location
  getMufasaBitmap(bmp).drawCircle(pos, 3, true, clLime);
  getMufasaBitmap(bmp).drawBox(TBox([max(0, pos.x - 70), max(0, pos.y - 70),
                               min(w-5, pos.x + 70), min(h, pos.y + 70)]), false, clLime);

  cropBitmap(bmp, max(0, pos.x - 120), max(0, pos.y - 120),
                  min(w-10, pos.x + 120), min(h-10, pos.y + 120));

  // draw the ingame minimap on and info
  mid := minimap.getCenterPoint();

  getBitmapSize(bmp, w, h);
  setBitmapSize(bmp, w + 120, h);

  getMufasaBitmap(bmp).copyClientToBitmap(client.getIOManager(), false, w + 10, 10, mid.x-50, mid.y-50, mid.x+50, mid.y+50);
  getMufasaBitmap(bmp).drawText('pos: (' + toStr(pos.x) + ', ' + toStr(pos.y) + ')', point(w + 10, 120), clRed);
  getMufasaBitmap(bmp).drawText('took: ' + toStr(t) + 'ms', point(w + 10, 140), clRed);

  debugBitmap(bmp);
  freeBitmap(bmp);
end;

(*
  Gets the players postion.

  Example:
    writeln(sps.getPlayerPos());
*)
function TSPSArea.getPlayerPos(): TPoint;
var
  t, foundMatches, bmpW, bmpH: integer;
  bmpMinimap: TMufasaBitmap;
  smallMap: T3DIntegerArray;
  p: TPoint;
  searches: extended;
begin
  result := [-1, -1];

  if (not self.isSetup) then
  begin
    print('Unable to get players postion, sps isn''t setup', TDebug.ERROR);
    exit();
  end;

  if (not isLoggedIn()) then
    exit();

  t := getSystemTime();

  if (not spsAnyAngle) then
  begin
    if (inRange(minimap.getAngleDegrees(), 8, 352)) then
      minimap.setAngle(MM_DIRECTION_NORTH);

    bmpMinimap := SPS_GatherMinimap();
  end else
    bmpMinimap := SPS_GatherRotatedMinimap();

  bmpW := bmpMinimap.getWidth();
  bmpH := bmpMinimap.getHeight();

  SPS_BitmapToMap(bmpMinimap, self._accuracy, smallMap);

  foundMatches := SPS_FindMapInMap(p.x, p.y, self.__areaMap, smallMap, self._tolerance);
  searches := ((bmpW / self._accuracy) * (bmpH / self._accuracy));

  bmpMinimap.free();

  if ((foundMatches / searches) > self._minMatchPercent) then
  begin
    result.x := (p.x * self._accuracy + (bmpW div 2));
    result.y := (p.y * self._accuracy + (bmpW div 2));
  end else
    print(self.getName()+'.getPlayerPos(): Didn''t find enough matches accurately calc your postion', TDebug.WARNING);

  print(self.getName()+'.getPlayerPos(): result = ' + toStr(result) + ' took ' + intToStr(getSystemTime() - t) + ' ms');
end;

function SPS_PosToMM(pos, playerPos: TPoint; out res: TPoint): boolean;
var
  a: extended;
begin
  if (spsAnyAngle) then
  begin
    a := minimap.getAngleRadians();

    if (not inRange(degrees(a), 8, 352)) then // no need to rotate
      res := [minimap.cx + pos.x - playerPos.x, minimap.cy + pos.y - playerPos.y]
    else
      res := rotatePoint([minimap.cx + pos.x - playerPos.x, minimap.cy + pos.y - playerPos.y], a, minimap.cx, minimap.cy);
  end else
    res := [minimap.cx + pos.x - playerPos.x, minimap.cy + pos.y - playerPos.y];

  result := minimap.isPointOn(res);

  if (not result) then
    res := [-1, -1];
end;

function TSPSArea.walkToPos(pos: TPoint; playerPos: TPoint): boolean;
var
  p: TPoint;
begin
  result := false;

  if (SPS_PosToMM(pos, playerPos, p)) then
  begin
    result := true;

    // if distance is less than 10 then there is no real point walking.
    if (distance(p, minimap.getCenterPoint()) < 10) then
      exit;

    if (spsMultiMouse) then
      multiClick(p, 25, 3)
    else
      mouse(p, MOUSE_LEFT);

    if (minimap.isFlagPresent(3000 + random(500))) then
      minimap.waitPlayerMoving();

    if (minimap.isFlagPresent()) then  //case failed
      minimap.waitPlayerMoving();
  end;

  print('TSPSArea.walkToPos(): result = '+boolToStr(result));
end;

function TSPSArea.walkToPos(pos: TPoint): boolean; overload;
begin
  result := self.walkToPos(pos, self.getPlayerPos());
end;

function TSPSArea.walkPath(path: TPointArray): boolean;
var
  p, lastPos, mmPoint: TPoint;
  t, fails, h, l, i: integer;
begin
  result := false;;

  h := high(path);
  l := low(path);

  t := (getSystemTime() + randomRange(15000, 20000));

  repeat
    if (not isLoggedIn()) then
      exit(false);

    p := self.getPlayerPos();

    for i := h downto l do
      if (SPS_PosToMM(path[i], p, mmPoint)) then
      begin
        if (distance(minimap.getCenterPoint(), mmPoint) >= 10) then
        begin
          if (spsMultiMouse) then
            multiClick(mmPoint, 25, 3)
          else
            mouse(mmPoint, MOUSE_LEFT);

          if (minimap.isFlagPresent(2500 + random(500))) then
            minimap.waitFlag(10 + random(25));
        end;

        t := (getSystemTime() + randomRange(15000, 20000));

        result := (i = h) or (distance(path[i], path[h]) < 10);

        if (result) then
          break(2)
        else
          break();

      end;

    if (p.x = lastPos.x) and (p.y = lastPos.y) then
      inc(fails);

  until (getSystemTime() > t) or (fails > 5);

  if (minimap.isFlagPresent()) or (minimap.isPlayerMoving()) then
    minimap.waitPlayerMoving();

  print('TSPSArea.walkPath(): result = '+boolToStr(result));
end;

function TSPSArea.blindWalk(pos: TPoint): boolean;
var
  tries: integer;
  ctrlPoints: TPointArray;
  p: TPoint;
begin
  result := false;

  repeat
    if (not isLoggedIn()) then
      exit();

    p := self.getPlayerPos();

    inc(tries);

    if ((tries) > 10) then
      exit();
  until (not p.equals([-1, -1]));

  ctrlPoints := TPABetweenPoints(p, pos, 15 + random(25), 15);
  result := self.walkPath(ctrlPoints);

  print('TSPSArea.blindWalk(): result = '+boolToStr(result));
end;




